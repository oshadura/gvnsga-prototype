#pragma once

#ifndef __PCPPCA__
#define __PCPPCA__

#include <Eigen/Core>
#include <Eigen/SVD>
#include <Eigen/Dense>
#include <Eigen/Eigenvalues>

#include <unsupported/Eigen/MatrixFunctions>

#include "generic/Population.h"
#include "generic/TGenes.h"
#include "generic/GAVector.h"
#include "generic/GADouble.h"

#include "PCA.h"

#include <cmath>
#include <iostream>
#include <fstream>
#include <iostream>
#include <cmath>

namespace geantvmoop {

using namespace Eigen;

class PCPPCA : public PCA<PCPPCA> {

private:
  MatrixXd D, A, E;

public:
  PCPPCA() {}

  virtual ~PCPPCA() {}

  void LoadData(const char *data, char sep = ',') {
    unsigned int row = 0;
    std::ifstream reader;
    reader.open(data);
    if (reader.is_open()) {
      std::string line, token;
      while (std::getline(reader, line)) {
        std::stringstream tmp(line);
        unsigned int col = 0;
        while (std::getline(tmp, token, sep)) {
          if (D.rows() < row + 1) {
            D.conservativeResize(row + 1, D.cols());
          }
          if (D.cols() < col + 1) {
            D.conservativeResize(D.rows(), col + 1);
          }
          D(row, col) = std::atof(token.c_str());
          col++;
        }
        row++;
      }
      reader.close();
      // std::cout << "Filed was proccessed.." << std::endl;
      MatrixXd A = MatrixXd::Zero(D.rows(), D.cols());
      MatrixXd E = MatrixXd::Zero(D.rows(), D.cols());
      // D = D.array() * D.array();
    } else {
      std::cout << "Failed to read file..." << data << std::endl;
    }
  }

  template <typename F> void UploadPopulation(Population<F> &pop) {
    for (int i = 0; i < pop.size(); ++i) {
      auto individual = pop.GetTGenes(i);
      for (int j = 0; j < individual.size(); ++j) {
        auto gene = individual[j];
        if (D.rows() < i + 1) {
          D.conservativeResize(i + 1, D.cols());
        }
        if (D.cols() < j + 1) {
          D.conservativeResize(D.rows(), j + 1);
        }
        D(i, j) = gene.GetGAValue();
      }
    }
    MatrixXd A = MatrixXd::Zero(D.rows(), D.cols());
    MatrixXd E = MatrixXd::Zero(D.rows(), D.cols());
    // D = D.array() * D.array();
    std::string sep = "\n----------------------------------------\n";
    std::cout << D << sep;
  }

  template <typename F>
  void UnloadPopulation(Population<F> &newpop, MatrixXd &data) {
    // check if they are both the same size!
    // if (data.cols() != newpop.size())
    //  return;
    typename F::Input ind;
    std::vector<individual_t<F> > poplist;
    std::string sep = "\n----------------------------------------\n";
    for (int i = 0; i < data.rows(); ++i) {
      for (int j = 0; j < data.cols(); ++j) {
        // std::cout << "Gene to be added in a population[" << i << "," << j
        //          << "] is " << data(i, j) << std::endl;
        ind.push_back(data(i, j));
        // ind.SetGAValue(data(i, j));
      }
      // std::cout << "New gene added." << std::endl;
      TGenes<F> newind = ind;
      poplist.push_back(std::make_shared<geantvmoop::TGenes<F> >(newind));
      ind.clear();
    }
    newpop = Population<F>(poplist);
  }

  template <typename F> Population<F> MVAImpl(Population<F> &pop) {
    Population<F> result;
    UploadPopulation(pop);
    PCPPCAInexact();
    UnloadPopulation(result, A);
    return result;
  }
  // Double suppose to be F::Input
  int LargerThan(const VectorXd &v, double value) {
    int count = 0;
    for (int i = 0; i < v.size(); ++i) {
      if (v[i] > value)
        ++count;
    }
    return count;
  }

  void Print() {
    std::cout << "The original matirix; D = \n" << D << std::endl;
    std::cout << "Estimated row rank matrix: A = \n" << A << std::endl;
    std::cout << "Estimated sparse matrix: E = \n" << E << std::endl;
    std::cout << "Reconstructed matrix: A + E = \n" << A + E << std::endl;
    std::cout << "Reconstruction Error = \n" << (D - (A + E)).norm()
              << std::endl;
  }

  void PCPPCAExact() {

    const int M = D.rows();
    const int N = D.cols();

    // supplementary variable
    A = MatrixXd::Zero(M, N);
    E = MatrixXd::Zero(M, N);
    MatrixXd Y = D;
    ArrayXXd zero = ArrayXXd::Zero(M, N);

    // Parameters
    const double lambda = 1.0 / sqrt(std::max(M, N));
    const double rho = 6;

    JacobiSVD<MatrixXd> SVDSingularValues(Y);
    // Could be calculated through Eigen3
    const double NormTwo =
        SVDSingularValues.singularValues()(0); // can be tuned
    const double NormInf = Y.array().abs().maxCoeff() / lambda;
    const double DualNorm = std::max(NormTwo, NormInf);
    const double DNorm = D.norm(); // Frobeius norm

    Y /= DualNorm;

    double Mu = 0.5;

    const double MuBar = Mu * 1.0e+7;

    bool converged = false;

    int MaximumIteration = 1000;

    double ErrorTolerance = 1.0e-7;

    int TotalSVD = 0;

    int sv = 10;

    int StopCriterion = 1;

    int iter = 0;
    while (iter < MaximumIteration) {
      // update sparse matrix E
      ArrayXXd TemporaryT = D - A + (1.0 / Mu) * Y;
      E = (TemporaryT - lambda / Mu).max(zero) + (TemporaryT + lambda / Mu).min(zero);
      // force non-negative
      E = E.array().max(zero);
      // SVD
      JacobiSVD<MatrixXd> svd(D - E + (1.0 / Mu) * Y,
                              ComputeFullU | ComputeFullV);
      MatrixXd U = svd.matrixU();
      MatrixXd V = svd.matrixV();
      VectorXd singularValues = svd.singularValues();

      // truncate dimention
      int svp = LargerThan(singularValues, 1 / Mu);
      if (svp < sv) {
        sv = std::min(svp + 1, N);
      } else {
        sv = std::min(svp + static_cast<int>(0.05 * N + 0.5), N);
      }

      // update A matrix
      MatrixXd S_th =
          (singularValues.head(svp).array() - 1.0 / Mu).matrix().asDiagonal();
      A = U.leftCols(svp) * S_th * V.leftCols(svp).transpose();

      // force non-negative
      A = A.array().max(zero);

      TotalSVD += 1;

      MatrixXd Z = D - A - E;

      Y = Y + Mu * Z;

      Mu = std::min(Mu * rho, MuBar);

      // objective function
      double objective = Z.norm() / DNorm;

      if (objective < ErrorTolerance) {
        converged = true;
      }

      if (++iter >= MaximumIteration) {
        break;
      }
    }
  }
};
}

#endif